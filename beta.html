<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Number Match</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #f0f0f0;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
    padding: 20px;
  }
  h1 { margin-bottom: 10px; text-align: center; }

  #game {
    display: grid;
    grid-template-columns: repeat(8, auto);
    border: 1px solid #d0d0d0;
    margin-top: 20px;
  }

  .cell {
    background: #fff;
    border: 1px solid #d0d0d0;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 30px;
    cursor: pointer;
    user-select: none;
    min-width: 38px;
    min-height: 38px;
    padding: 3px;
    transition: background 0.3s, transform 0.2s;
  }

  .cell.selected { background: #87cefa; transform: scale(1.05); }

  /* Анімації */
  @keyframes bounceHint {
    0%,100% { transform: translateY(0); }
    30% { transform: translateY(-15px); }
    50% { transform: translateY(0); }
    70% { transform: translateY(-8px); }
  }
  .hint { background: #90ee90; animation: bounceHint 0.8s ease-out; }

  @keyframes pulseRed {
    0%,100% { background: #ffcccc; transform: translateY(0); }
    30%,70% { background: #ff6666; transform: translateY(-10px); }
    50% { background: #ff9999; transform: translateY(0); }
  }
  .wrong { animation: pulseRed 0.8s ease-out; }

  #level { margin-top: 20px; font-size: 18px; }
  #message { margin-top: 10px; font-size: 16px; color: #d9534f; }

  .icon-bar {
    display: flex;
    gap: 14px;
    margin-top: 10px;
  }

  .icon-button {
    background: none;
    border: none;
    cursor: pointer;
    padding: 6px;
    transition: transform 0.2s ease;
  }

  .icon-button svg {
    stroke: #333;
    width: 32px;
    height: 32px;
    transform: none;
  }

  @media (hover: hover) and (pointer: fine) {
    .icon-button:not(.rotate-animation):hover svg {
      transform: scale(1.15);
    }
  }

  @keyframes blink {
    0%, 100% { stroke: #FFD700; transform: scale(1); }
    50% { stroke: #FFA500; transform: scale(1.2); }
  }
  .blinking svg { animation: blink 1s infinite; }

  @keyframes rotate360 {
    0% { transform: rotate(0deg); }
    50% { transform: rotate(360deg); }
    100% { transform: rotate(0deg); }
  }
  .rotate-animation svg { animation: rotate360 0.6s ease; }

</style>
</head>
<body>

<h1>Number Match</h1>
<div id="level">Рівень: 1</div>
<div id="game"></div>
<div id="message"></div>

<div class="icon-bar">
  <!-- Перезапуск -->
  <button id="restartBtn" class="icon-button" title="Перезапустити гру">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="#333" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="1 4 1 10 7 10"></polyline>
      <path d="M3.51 15a9 9 0 1 0 3.13-9.36L1 10"></path>
    </svg>
  </button>

  <!-- Додати рядок -->
  <button id="addRowBtn" class="icon-button" title="Додати рядок">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="#333" stroke-linecap="round" stroke-linejoin="round">
      <line x1="12" y1="5" x2="12" y2="19"></line>
      <line x1="5" y1="12" x2="19" y2="12"></line>
    </svg>
  </button>

  <!-- Підказка -->
  <button id="hintBtn" class="icon-button" title="Підказка">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="#333" stroke-linecap="round" stroke-linejoin="round">
      <path d="M9 18h6M10 22h4M12 2a7 7 0 0 1 7 7c0 2.485-1.5 4.5-3 6a4 4 0 0 0-1 3H11a4 4 0 0 0-1-3c-1.5-1.5-3-3.515-3-6a7 7 0 0 1 7-7z"/>
    </svg>
  </button>
</div>

<script>
const state = {
  rows: 10, cols: 8, level: 1,
  numbers: [], selected: [], blocked: false
};
const game = document.getElementById('game');
const levelEl = document.getElementById('level');
const message = document.getElementById('message');
const hintBtn = document.getElementById('hintBtn');

document.getElementById('restartBtn').onclick = () => animateIcon('restart');
document.getElementById('addRowBtn').onclick = () => animateIcon('add');
hintBtn.onclick = () => animateIcon('hint');

function animateIcon(type) {
  const btn = {
    restart: document.getElementById('restartBtn'),
    add: document.getElementById('addRowBtn'),
    hint: hintBtn
  }[type];
  const svg = btn.querySelector('svg');
  if (type === 'restart') {
    btn.classList.add('rotate-animation');
    setTimeout(() => btn.classList.remove('rotate-animation'), 600);
    startGame();
  } else if (type === 'add') {
    svg.style.transform = "scale(1.4)";
    setTimeout(() => svg.style.transform = "", 400);
    addRow();
  } else if (type === 'hint') {
    svg.style.stroke = "#FFD700"; svg.style.transform = "scale(1.2)";
    setTimeout(() => { svg.style.stroke = "#333"; svg.style.transform = ""; }, 400);
    showHint();
  }
}

function getMatrix() {
  return Array.from({length: state.rows}, (_, r) =>
    state.numbers.slice(r * state.cols, (r + 1) * state.cols)
  );
}

function flatten(matrix) { return matrix.flat(); }

function shuffle(arr) { return arr.sort(() => Math.random() - 0.5); }

function generatePairs(count) {
  const pairs = [], combos = [];
  for (let i = 1; i <= 9; i++) {
    combos.push([i, i]);
    if (10 - i !== i && 10 - i <= 9 && 10 - i >= 1) combos.push([i, 10 - i]);
  }
  while (pairs.length < count) pairs.push(...combos[Math.floor(Math.random() * combos.length)]);
  return shuffle(pairs.slice(0, count));
}

function renderGrid() {
  game.innerHTML = '';
  state.numbers.forEach((num, i) => {
    const cell = document.createElement('div');
    cell.className = 'cell';
    if (num !== null) cell.textContent = num;
    cell.onclick = () => selectCell(i);
    game.appendChild(cell);
  });
}

function updateCells() {
  const cells = document.querySelectorAll('.cell');
  state.numbers.forEach((n, i) => cells[i].textContent = n ?? '');
}

function startGame() {
  state.blocked = false;
  state.selected = [];
  const total = state.rows * state.cols;
  const startCount = 5 * state.cols;
  const arr = generatePairs(startCount);
  state.numbers = [...arr, ...Array(total - startCount).fill(null)];
  renderGrid();
  updateHintBlink();
  message.textContent = '';
}

function canConnect(i1, i2) {
  const r1 = Math.floor(i1 / state.cols), c1 = i1 % state.cols;
  const r2 = Math.floor(i2 / state.cols), c2 = i2 % state.cols;
  const dr = Math.sign(r2 - r1), dc = Math.sign(c2 - c1);
  if (dr === 0 && dc === 0) return false;
  let r = r1 + dr, c = c1 + dc;
  while (r !== r2 || c !== c2) {
    if (state.numbers[r * state.cols + c] !== null) return false;
    r += dr; c += dc;
  }
  return true;
}

async function selectCell(i) {
  if (state.blocked || state.numbers[i] === null) return;
  const cells = document.querySelectorAll('.cell');
  if (state.selected.includes(i)) {
    cells[i].classList.remove('selected');
    state.selected = state.selected.filter(x => x !== i);
    return;
  }
  state.selected.push(i);
  cells[i].classList.add('selected');
  if (state.selected.length === 2) {
    state.blocked = true;
    await checkMatch();
  }
}

async function checkMatch() {
  const [i1, i2] = state.selected;
  const n1 = state.numbers[i1], n2 = state.numbers[i2];
  const cells = document.querySelectorAll('.cell');
  if ((n1 === n2 || n1 + n2 === 10) && canConnect(i1, i2)) {
    state.numbers[i1] = null;
    state.numbers[i2] = null;
    updateCells();
    cells[i1].classList.remove('selected');
    cells[i2].classList.remove('selected');
    compressRows();
    checkLevelComplete();
    state.selected = [];
  } else {
    cells[i1].classList.add('wrong');
    cells[i2].classList.add('wrong');
    message.textContent = 'Не можна поєднати!';
    await new Promise(r => setTimeout(r, 800));
    ['wrong', 'selected'].forEach(cls => {
      cells[i1].classList.remove(cls);
      cells[i2].classList.remove(cls);
    });
    state.selected = [];
    message.textContent = '';
  }
  state.blocked = false;
  updateHintBlink();
}

function compressRows() {
  const matrix = getMatrix().filter(row => row.some(n => n !== null));
  while (matrix.length < state.rows) matrix.push(Array(state.cols).fill(null));
  state.numbers = flatten(matrix);
  updateCells();
}

function addRow() {
  if (state.blocked) return;
  const matrix = getMatrix();
  const last = matrix.map(r => r.some(n => n !== null)).lastIndexOf(true);
  if (last < state.rows - 1) {
    const newRow = generatePairs(state.cols);
    matrix.splice(last + 1, 0, newRow);
    if (matrix.length > state.rows) matrix.pop();
    state.numbers = flatten(matrix);
    updateCells();
  }
}

function hasHint() {
  for (let i = 0; i < state.numbers.length; i++) {
    if (state.numbers[i] === null) continue;
    for (let j = i + 1; j < state.numbers.length; j++) {
      if (state.numbers[j] === null) continue;
      if ((state.numbers[i] === state.numbers[j] || state.numbers[i] + state.numbers[j] === 10) && canConnect(i, j)) return [i, j];
    }
  }
  return null;
}

function showHint() {
  if (state.blocked) return;
  const cells = document.querySelectorAll('.cell');
  const pair = hasHint();
  if (!pair) {
    message.textContent = 'Підказок немає!';
    setTimeout(() => message.textContent = '', 1000);
    return;
  }
  state.blocked = true;
  const [i1, i2] = pair;
  cells[i1].classList.add('hint');
  cells[i2].classList.add('hint');
  setTimeout(() => {
    cells[i1].classList.remove('hint');
    cells[i2].classList.remove('hint');
    state.blocked = false;
  }, 800);
}

function updateHintBlink() {
  hintBtn.classList.toggle('blinking', !!hasHint());
}

function checkLevelComplete() {
  if (state.numbers.every(n => n === null)) {
    state.level++;
    levelEl.textContent = 'Рівень: ' + state.level;
    startGame();
  }
}

startGame();
</script>
</body>
</html>
