<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Number Match</title>
  <style>
    :root {
      --bg: #0f1220;
      --panel: #171b2e;
      --panel-2: #1f2440;
      --text: #e9ecf2;
      --muted: #aab0c0;
      --accent: #6ae3ff;
      --good: #3fdc84;
      --bad: #ff6b6b;
      --tile: #242a4d;
      --tile-hover: #2d3563;
      --shadow: rgba(0,0,0,.25);
      --radius: 16px;
      --gap: 10px;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 75% -10%, #1b2142, var(--bg));
      color: var(--text);
      font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      display: grid;
      grid-template-rows: auto 1fr auto;
      min-height: 100dvh;
    }

    header {
      padding: 10px 12px env(safe-area-inset-top) 10px;
      position: sticky; top: 0; z-index: 10;
      background: linear-gradient(180deg, rgba(15,18,32,.9), rgba(15,18,32,.6) 60%, rgba(15,18,32,0));
      backdrop-filter: saturate(1.2) blur(10px);
    }

    .toolbar {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: center;
      max-width: 920px; margin: 0 auto;
    }

    .title {
      display: flex; align-items: center; gap: 10px;
      font-weight: 700; letter-spacing: .3px;
    }

    .title .badge {
      font-size: 12px; color: var(--bg); background: var(--accent);
      padding: 3px 8px; border-radius: 999px; font-weight: 700;
    }

    .controls { display: flex; gap: 8px; flex-wrap: wrap; justify-self: end; }

    button {
      -webkit-tap-highlight-color: transparent;
      background: var(--panel);
      color: var(--text);
      border: 1px solid #2a3058;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 600; letter-spacing: .2px;
      box-shadow: 0 2px 8px var(--shadow);
      cursor: pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      touch-action: manipulation;
      min-height: 40px;
    }
    button:active { transform: translateY(1px) scale(.99); }
    button:hover { background: var(--panel-2); }

    .primary { border-color: #3553ff55; background: linear-gradient(180deg, #2230a8, #1b247f); }
    .primary:hover { filter: brightness(1.05); }

    .pill {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 8px 10px; background: #141833; border: 1px solid #2a3058; border-radius: 999px; font-size: 13px;
    }

    main { max-width: 920px; width: 100%; margin: 8px auto 16px; padding: 0 12px; }

    .hud {
      display: grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap: 8px; margin-bottom: 10px;
    }
    .hud .card {
      background: var(--panel); border: 1px solid #2a3058; border-radius: var(--radius);
      padding: 10px; text-align: center; box-shadow: 0 8px 20px var(--shadow);
    }
    .label { font-size: 12px; color: var(--muted); }
    .value { font-size: clamp(18px, 4vw, 22px); font-weight: 800; letter-spacing: .4px; }

    .board-wrap {
      background: linear-gradient(180deg, #151937, #10142b);
      border: 1px solid #2a3058; border-radius: var(--radius);
      padding: 10px; box-shadow: 0 10px 30px var(--shadow);
    }

    .board {
      display: grid;
      /* Responsive columns: 6 on narrow phones -> 9 on wide screens */
      grid-template-columns: repeat(var(--cols), 1fr);
      gap: var(--gap);
      min-height: 280px;
      user-select: none;
    }

    .tile {
      aspect-ratio: 1 / 1;
      border-radius: 14px;
      display: grid; place-items: center;
      background: var(--tile);
      border: 1px solid #323a6b;
      font-weight: 800; font-size: clamp(18px, 5.5vw, 28px);
      letter-spacing: .3px;
      box-shadow: 0 6px 14px var(--shadow);
      transition: background .12s ease, transform .06s ease, border-color .15s ease, opacity .2s ease;
      position: relative;
    }
    .tile:hover { background: var(--tile-hover); }
    .tile.removed { opacity: .18; filter: saturate(.2) blur(.2px); pointer-events: none; }
    .tile.selected { outline: 2px solid var(--accent); outline-offset: 2px; transform: translateY(-1px); }
    .tile.hint { box-shadow: 0 0 0 3px rgba(106,227,255,.35), inset 0 0 0 1px rgba(106,227,255,.5); }

    .row-divider { grid-column: 1 / -1; height: 2px; background: linear-gradient(90deg, transparent, #2a3058, transparent); margin: 2px 0; border-radius: 2px; opacity: .5; }

    .footer {
      padding: 10px 12px env(safe-area-inset-bottom);
      display: grid; grid-template-columns: 1fr; gap: 10px; max-width: 920px; margin: 0 auto 10px; width: 100%;
    }

    .notice { color: var(--muted); font-size: 13px; text-align: center; }

    @media (min-width: 420px) {
      .controls { gap: 10px; }
      .hud { grid-template-columns: repeat(6, minmax(0,1fr)); }
    }
  </style>
</head>
<body>
  <header>
    <div class="toolbar" role="toolbar" aria-label="Панель керування грою">
      <div class="title">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 2a10 10 0 1 0 10 10A10.011 10.011 0 0 0 12 2Zm1 15h-2v-2h2Zm0-4h-2V7h2Z" fill="currentColor"/></svg>
        <span>Number Match</span>
        <span class="badge">mobile</span>
      </div>
      <div class="controls">
        <button id="newGameBtn" class="primary" aria-label="Нова гра">Нова гра</button>
        <button id="addRowBtn" aria-label="Додати ряд">+ Ряд</button>
        <button id="hintBtn" aria-label="Підказка">Підказка</button>
        <button id="undoBtn" aria-label="Скасувати хід">Скасувати</button>
      </div>
    </div>
  </header>

  <main>
    <section class="hud" aria-live="polite">
      <div class="card"><div class="label">Рівень</div><div class="value" id="level">1</div></div>
      <div class="card"><div class="label">Рядків</div><div class="value" id="rows">0</div></div>
      <div class="card"><div class="label">Ходи</div><div class="value" id="moves">0</div></div>
      <div class="card"><div class="label">Пари</div><div class="value" id="pairs">0</div></div>
      <div class="card"><div class="label">Сума</div><div class="value" id="sum">0</div></div>
      <div class="card"><div class="label">Статус</div><div class="value" id="status">Грай!</div></div>
    </section>

    <section class="board-wrap">
      <div id="board" class="board" role="grid" aria-label="Ігрове поле"></div>
    </section>

    <p class="notice">Правила: видаляй дві плитки з однаковими числами <b>або</b> такі, що в сумі дають <b>10</b>. Вони мають бути <b>в одному рядку або колонці</b> без інших плиток між ними. Якщо немає ходів — натисни «+ Ряд».</p>
  </main>

  <div class="footer">
    <div class="pill" id="message" aria-live="polite">Порада: торкнись двох сумісних плиток, щоб прибрати їх.</div>
  </div>

  <script>
  (() => {
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const rowsEl = document.getElementById('rows');
    const levelEl = document.getElementById('level');
    const movesEl = document.getElementById('moves');
    const pairsEl = document.getElementById('pairs');
    const sumEl = document.getElementById('sum');
    const messageEl = document.getElementById('message');

    const newGameBtn = document.getElementById('newGameBtn');
    const addRowBtn = document.getElementById('addRowBtn');
    const hintBtn = document.getElementById('hintBtn');
    const undoBtn = document.getElementById('undoBtn');

    // Responsive columns: 6..9 depending on viewport width
    const computeCols = () => {
      const w = window.innerWidth;
      if (w < 360) return 6;
      if (w < 420) return 7;
      if (w < 520) return 8;
      return 9;
    };

    // Game state
    let state = {
      level: 1,
      cols: computeCols(),
      grid: [], // 2D array of cells {n: number|null, id: string}
      moves: 0,
      pairs: 0,
      history: [], // for undo
      selection: [], // [cellId, cellId]
    };

    // Persistence
    const LS_KEY = 'number-match-mobile-v1';
    const save = () => localStorage.setItem(LS_KEY, JSON.stringify(state));
    const load = () => {
      try {
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) return false;
        const obj = JSON.parse(raw);
        if (!obj || !Array.isArray(obj.grid)) return false;
        state = { ...state, ...obj };
        // ensure cols aligns with device now
        state.cols = computeCols();
        return true;
      } catch { return false; }
    };

    // Helpers
    const uid = () => Math.random().toString(36).slice(2, 9);
    const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

    const setColsCSS = () => {
      boardEl.style.setProperty('--cols', state.cols);
      const gap = state.cols >= 9 ? 10 : state.cols === 8 ? 10 : 8;
      boardEl.style.setProperty('--gap', gap + 'px');
    };

    const freshRow = (cols) => Array.from({ length: cols }, () => ({ n: rand(1,9), id: uid() }));

    const newGame = () => {
      state = {
        level: 1,
        cols: computeCols(),
        grid: [],
        moves: 0,
        pairs: 0,
        history: [],
        selection: [],
      };
      // Start with 6 rows for a nice board density
      for (let i=0; i<6; i++) state.grid.push(freshRow(state.cols));
      render();
      save();
      toast('Нова гра почалась. Успіхів!');
    };

    const toast = (text) => { messageEl.textContent = text; };

    const coordsOf = (cellId) => {
      for (let r=0; r<state.grid.length; r++) {
        const c = state.grid[r].findIndex(t => t && t.id === cellId);
        if (c !== -1) return { r, c };
      }
      return null;
    };

    const cellAt = (r, c) => (state.grid[r] && state.grid[r][c]) || null;

    const isRemoved = (cell) => !cell || cell.n == null;

    const canMatch = (a, b) => {
      if (!a || !b || a.id === b.id) return false;
      if (a.n == null || b.n == null) return false;
      const ruleOK = (a.n === b.n) || (a.n + b.n === 10);
      if (!ruleOK) return false;
      // must be same row or same column
      const A = coordsOf(a.id), B = coordsOf(b.id);
      if (!A || !B) return false;
      if (A.r === B.r) {
        const [from, to] = A.c < B.c ? [A.c+1, B.c-1] : [B.c+1, A.c-1];
        for (let x = from; x <= to; x++) if (!isRemoved(cellAt(A.r, x))) return false;
        return true;
      }
      if (A.c === B.c) {
        const [from, to] = A.r < B.r ? [A.r+1, B.r-1] : [B.r+1, A.r-1];
        for (let y = from; y <= to; y++) if (!isRemoved(cellAt(y, A.c))) return false;
        return true;
      }
      return false; // different row & column
    };

    const removePair = (a, b) => {
      // push to history for undo
      state.history.push(JSON.stringify(state));
      const A = coordsOf(a.id), B = coordsOf(b.id);
      state.grid[A.r][A.c] = { ...a, n: null };
      state.grid[B.r][B.c] = { ...b, n: null };
      state.moves++; state.pairs++;
      state.selection = [];
      compactBoard();
      render();
      save();
    };

    // Remove empty rows at the bottom and tidy any fully empty rows inside
    const compactBoard = () => {
      // Drop rows that are entirely removed
      state.grid = state.grid.filter(row => row.some(t => t && t.n != null));
      // Ensure at least 1 row exists
      if (state.grid.length === 0) state.grid.push(freshRow(state.cols));
    };

    const addRow = () => {
      state.history.push(JSON.stringify(state));
      state.grid.push(freshRow(state.cols));
      render();
      save();
      toast('Додано новий ряд.');
    };

    const undo = () => {
      const snap = state.history.pop();
      if (!snap) return toast('Немає що скасовувати.');
      state = JSON.parse(snap);
      render();
      save();
      toast('Попередній хід скасовано.');
    };

    const findHint = () => {
      // Scan rows
      for (let r=0; r<state.grid.length; r++) {
        const row = state.grid[r];
        for (let i=0; i<row.length; i++) {
          const a = row[i]; if (!a || a.n == null) continue;
          for (let j=i+1; j<row.length; j++) {
            const b = row[j];
            if (!b || b.n == null) continue;
            if (canMatch(a, b)) return [a.id, b.id];
          }
        }
      }
      // Scan columns
      for (let c=0; c<state.cols; c++) {
        let prev = null;
        for (let r=0; r<state.grid.length; r++) {
          const t = cellAt(r, c);
          if (!t || t.n == null) continue;
          if (prev && canMatch(prev, t)) return [prev.id, t.id];
          prev = t;
        }
      }
      return null;
    };

    const updateHUD = () => {
      rowsEl.textContent = String(state.grid.length);
      levelEl.textContent = String(state.level);
      movesEl.textContent = String(state.moves);
      pairsEl.textContent = String(state.pairs);
      // Show sum of selected
      const s = state.selection
        .map(id => coordsOf(id))
        .map(pos => pos ? cellAt(pos.r, pos.c)?.n ?? 0 : 0)
        .reduce((a,b) => a+b, 0);
      sumEl.textContent = String(s);

      // Status message
      const left = countNumbers();
      statusEl.textContent = left === 0 ? 'Поле очищене!' : (findHint() ? 'Хід існує' : 'Ходів немає');
    };

    const countNumbers = () => {
      let cnt = 0;
      for (const row of state.grid) for (const t of row) if (t && t.n != null) cnt++;
      return cnt;
    };

    const render = () => {
      setColsCSS();
      boardEl.innerHTML = '';
      // Build DOM grid
      for (let r=0; r<state.grid.length; r++) {
        const row = state.grid[r];
        for (let c=0; c<state.cols; c++) {
          const tile = row[c];
          const div = document.createElement('button');
          div.className = 'tile';
          div.setAttribute('role','gridcell');
          div.setAttribute('aria-label', tile?.n != null ? `Плитка ${tile.n}` : 'Порожньо');
          div.dataset.r = r; div.dataset.c = c;
          if (!tile || tile.n == null) {
            div.classList.add('removed');
            div.textContent = '';
            div.disabled = true;
          } else {
            div.textContent = String(tile.n);
            if (state.selection.includes(tile.id)) div.classList.add('selected');
          }
          boardEl.appendChild(div);
        }
        // Visual row divider to help eyes on mobile
        if (r < state.grid.length - 1) {
          const sep = document.createElement('div');
          sep.className = 'row-divider';
          boardEl.appendChild(sep);
        }
      }
      updateHUD();
    };

    const clearHints = () => boardEl.querySelectorAll('.tile.hint').forEach(el => el.classList.remove('hint'));

    const showHint = () => {
      clearHints();
      const pair = findHint();
      if (!pair) return toast('Ходів немає. Додай ряд або почни спочатку.');
      for (const id of pair) {
        const pos = coordsOf(id); if (!pos) continue;
        const sel = boardEl.querySelector(`.tile[data-r="${pos.r}"][data-c="${pos.c}"]`);
        sel?.classList.add('hint');
      }
      toast('Знайдено можливу пару.');
    };

    // User interactions
    boardEl.addEventListener('click', (e) => {
      const btn = e.target.closest('.tile');
      if (!btn) return;
      const r = +btn.dataset.r, c = +btn.dataset.c;
      const tile = cellAt(r, c);
      if (!tile || tile.n == null) return;

      // Toggle selection
      const idx = state.selection.indexOf(tile.id);
      if (idx >= 0) state.selection.splice(idx, 1);
      else {
        if (state.selection.length === 2) state.selection.shift();
        state.selection.push(tile.id);
      }

      // If two selected, attempt match
      if (state.selection.length === 2) {
        const [idA, idB] = state.selection;
        const Apos = coordsOf(idA), Bpos = coordsOf(idB);
        const A = Apos ? cellAt(Apos.r, Apos.c) : null;
        const B = Bpos ? cellAt(Bpos.r, Bpos.c) : null;
        if (A && B && canMatch(A, B)) {
          removePair(A, B);
          toast('Пара прибрана!');
        } else {
          // Small feedback
          btn.animate([{ transform: 'translateY(0)' }, { transform: 'translateY(2px)' }, { transform: 'translateY(0)' }], { duration: 120 });
          // Keep last clicked + closest compatible if exists
          if (state.selection.length === 2) state.selection = [tile.id];
          render();
          toast('Не підходить. Потрібно однакові або у сумі 10 і в одному рядку/колонці без перешкод.');
        }
      } else {
        render();
      }
    }, { passive: true });

    // Controls
    newGameBtn.addEventListener('click', () => newGame());
    addRowBtn.addEventListener('click', () => addRow());
    hintBtn.addEventListener('click', () => showHint());
    undoBtn.addEventListener('click', () => undo());

    // Resize handling: reflow columns but keep data
    window.addEventListener('resize', () => {
      const newCols = computeCols();
      if (newCols === state.cols) return;
      // Re-wrap each row to new column count while preserving items order
      const flat = state.grid.flat().filter(t => t && (t.n != null || t.n === null));
      state.cols = newCols;
      state.grid = [];
      for (let i=0; i<flat.length; i += newCols) {
        state.grid.push(flat.slice(i, i+newCols));
      }
      render();
      save();
    });

    // Init
    if (!load()) newGame();
    else { setColsCSS(); render(); toast('Продовжуємо збережену гру.'); }
  })();
  </script>
</body>
</html>
