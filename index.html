<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Number Match (Simple)</title>
  <style>
    :root{
      --bg:#f0f4f8;            /* світлий фон */
      --panel:#ffffffcc;       /* світла панель */
      --card:#ffffff;          /* світлі клітинки */
      --primary:#0284c7;       /* синій */
      --ok:#16a34a;            /* зелений */
      --bad:#dc2626;           /* червоний */
      --muted:#64748b;         /* сірий */
      --text:#0f172a;          /* темний текст */
      --grid-size: 9;
      --cell: min(9.8vmin, 52px);
      --radius: 12px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.3 system-ui, sans-serif}
    .app{max-width: min(95vw, 880px);margin: 24px auto;padding: 20px}
    .header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:14px}
    .title{font-size:clamp(20px, 3.6vmin, 28px);font-weight:800}
    .panel{background:var(--panel);border:1px solid #cbd5e1;border-radius:var(--radius);padding:14px 16px;display:flex;gap:18px;align-items:center;flex-wrap:wrap}
    .stat{display:flex;gap:8px;align-items:center;background:#f8fafc;border:1px solid #cbd5e1;padding:8px 12px;border-radius:12px}
    .stat b{font-size:18px}
    .grid-wrap{margin-top:14px;background:var(--panel);border:1px solid #cbd5e1;border-radius:calc(var(--radius) + 6px);padding:16px;box-shadow:0 4px 12px #00000010}
    .grid{display:grid;grid-template-columns:repeat(var(--grid-size), var(--cell));gap:8px;justify-content:center}
    .cell{color: var(--text);position:relative;width:var(--cell);height:var(--cell);display:grid;place-items:center;border-radius:8px;background:var(--card);border:1px solid #cbd5e1;cursor:pointer;user-select:none;transition:transform .08s ease, box-shadow .2s ease, border-color .12s ease}
    .cell[data-empty="1"]{visibility:hidden}
    .num{font-weight:700;font-size:calc(var(--cell) * .44)}
    .cell:hover{transform:translateY(-2px)}
    .cell.selected{box-shadow:0 0 0 3px #38bdf866 inset, 0 0 0 1px var(--primary);border-color:var(--primary)}
    .cell.good{animation:flash-good .55s both}
    .cell.bad{animation:flash-bad .5s both}
    @keyframes flash-good{0%{box-shadow:0 0 0 0 var(--ok)} 30%{box-shadow:0 0 0 6px #22c55e55} 100%{box-shadow:0 0 0 0 transparent}}
    @keyframes flash-bad{0%{box-shadow:0 0 0 0 var(--bad)} 35%{box-shadow:0 0 0 6px #ef444455} 100%{box-shadow:0 0 0 0 transparent}}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;margin-top:14px}
    .toolbar button{appearance:none;border:1px solid #cbd5e1;border-radius:8px;background:var(--primary);color:#fff;font-weight:700;padding:10px 14px;cursor:pointer}
    .toolbar button.secondary{background:#f1f5f9;color:var(--text)}
    button:disabled{opacity:.6;cursor:not-allowed}
    .rules{color:var(--muted);font-size:14px;margin-top:8px}
    .footer{margin-top:18px;color:var(--muted);font-size:12px}
    .footer a{color:var(--primary)}
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div class="title">Number Match — спрощена версія</div>
      <div class="panel" id="panel">
        <div class="stat">Очки: <b id="score">0</b></div>
        <div class="stat">Хід: <b id="moves">0</b></div>
        <div class="stat">Рівень: <b id="level">1</b></div>
        <div class="stat">Час: <b id="time">00:00</b></div>
      </div>
    </div>

    <div class="grid-wrap">
      <div id="grid" class="grid" aria-label="Ігрове поле"></div>
      <div class="toolbar">
        <button id="newGame">Нова гра</button>
        <button id="hintBtn" class="secondary">Підказка</button>
        <button id="shuffleBtn" class="secondary">Перемішати</button>
      </div>
      <div class="rules">Правила (спрощені): виберіть дві клітинки з однаковими числами <u>або</u> такими, що в сумі дають 10. Пара має бути <b>сусідньою</b> (по діагоналі теж можна). Успішна пара зникає, числа падають вниз, зверху зʼявляються нові. Набирайте очки якомога швидше.</div>
    </div>

    <div class="footer">Це навчальний клон під мобільний/десктоп браузер. Можу додати повні правила, збереження прогресу й таблицю рекордів.</div>
  </div>

<script>
(() => {
  const size = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--grid-size')) || 9;
  const gridEl = document.getElementById('grid');
  const scoreEl = document.getElementById('score');
  const movesEl = document.getElementById('moves');
  const levelEl = document.getElementById('level');
  const timeEl  = document.getElementById('time');
  const hintBtn = document.getElementById('hintBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const newGameBtn = document.getElementById('newGame');

  /*** State ***/
  let board = [];           // 2D array of ints (1..9) or null
  let selected = [];        // [r,c] pairs
  let score = 0, moves = 0, level = 1;
  let timer = null, seconds = 0;

  function rand() { return 1 + Math.floor(Math.random()*9); }

  function startTimer(){
    if (timer) clearInterval(timer);
    seconds = 0;
    timer = setInterval(() => { seconds++; timeEl.textContent = fmtTime(seconds); }, 1000);
  }
  const fmtTime = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;

  function newBoard(){
    board = Array.from({length:size}, () => Array.from({length:size}, rand));
    selected = []; score = 0; moves = 0; level = 1;
    updateHUD();
    render();
    startTimer();
  }

  function updateHUD(){
    scoreEl.textContent = score;
    movesEl.textContent = moves;
    levelEl.textContent = level;
  }

  function render(){
    gridEl.innerHTML = '';
    for (let r=0;r<size;r++) for (let c=0;c<size;c++) {
      const val = board[r][c];
      const cell = document.createElement('button');
      cell.className = 'cell';
      cell.setAttribute('data-row', r);
      cell.setAttribute('data-col', c);
      cell.setAttribute('aria-label', val ? `Клітинка ${r+1},${c+1}, число ${val}` : `Порожня`);
      if (val == null) cell.dataset.empty = '1';
      const span = document.createElement('div');
      span.className = 'num';
      span.textContent = val ?? '';
      cell.appendChild(span);
      cell.addEventListener('click', onCellClick);
      gridEl.appendChild(cell);
    }
  }

  function onCellClick(e){
    const cell = e.currentTarget;
    const r = +cell.dataset.row, c = +cell.dataset.col;
    if (board[r][c] == null) return;

    const idx = selected.findIndex(([sr,sc]) => sr===r && sc===c);
    if (idx>=0){ // deselect
      selected.splice(idx,1); cell.classList.remove('selected'); return;
    }
    if (selected.length===2) clearSelection();

    selected.push([r,c]);
    cell.classList.add('selected');

    if (selected.length===2){
      const ok = isValidPair(selected[0], selected[1]);
      flashPair(selected, ok);
      if (ok){
        removePair(selected[0], selected[1]);
      }
      setTimeout(() => clearSelection(), 180);
    }
  }

  function clearSelection(){
    document.querySelectorAll('.cell.selected').forEach(el=>el.classList.remove('selected'));
    selected = [];
  }

  /** Rules: same number OR sum to 10 AND adjacent (8-neighbourhood) **/
  function isValidPair(a,b){
    const [r1,c1]=a,[r2,c2]=b;
    if (r1===r2 && c1===c2) return false;
    const v1 = board[r1][c1], v2 = board[r2][c2];
    if (v1==null || v2==null) return false;
    const same = v1===v2; const sum10 = v1+v2===10;
    const dr = Math.abs(r1-r2), dc = Math.abs(c1-c2);
    const adjacent = dr<=1 && dc<=1; // includes diagonals
    return adjacent && (same || sum10);
  }

  function flashPair(pair, ok){
    pair.forEach(([r,c]) => {
      const el = getCellEl(r,c);
      el.classList.add(ok? 'good':'bad');
      setTimeout(()=>el.classList.remove('good','bad'), 420);
    });
  }

  function getCellEl(r,c){
    return gridEl.children[r*size + c];
  }

  function removePair(a,b){
    const cells = [a,b];
    cells.forEach(([r,c])=> board[r][c]=null);
    moves++; score += 10; // base points
    collapseAndFill();
    updateHUD();
    if (!anyMovesLeft()){
      // make it a bit harder each clear
      level++; addRandomObstacles();
      if (!anyMovesLeft()) shuffleBoard();
    }
  }

  function collapseAndFill(){
    // gravity: numbers fall down in each column, then new numbers appear on top
    for (let c=0;c<size;c++){
      const col = [];
      for (let r=0;r<size;r++) if (board[r][c]!=null) col.push(board[r][c]);
      for (let r=size-1;r>=0;r--){
        board[r][c] = col.pop() ?? null;
      }
      for (let r=0;r<size;r++) if (board[r][c]==null) board[r][c]=rand();
    }
    render();
  }

  function neighbours(r,c){
    const res=[];
    for (let dr=-1;dr<=1;dr++) for (let dc=-1;dc<=1;dc++){
      if (dr===0 && dc===0) continue;
      const rr=r+dr, cc=c+dc;
      if (rr>=0&&rr<size&&cc>=0&&cc<size) res.push([rr,cc]);
    }
    return res;
  }

  function anyMovesLeft(){
    for (let r=0;r<size;r++) for (let c=0;c<size;c++){
      const v = board[r][c];
      for (const [rr,cc] of neighbours(r,c)){
        const w = board[rr][cc];
        if (v===w || v+w===10) return true;
      }
    }
    return false;
  }

  function findHint(){
    for (let r=0;r<size;r++) for (let c=0;c<size;c++){
      const v = board[r][c];
      for (const n of neighbours(r,c)){
        const w = board[n[0]][n[1]];
        if (v===w || v+w===10) return [[r,c], n];
      }
    }
    return null;
  }

  function addRandomObstacles(){
    // As level grows, briefly invert a few cells to make the board different (visual shake-up)
    const swaps = Math.min(6, 2 + level);
    for (let i=0;i<swaps;i++){
      const r1 = Math.floor(Math.random()*size), c1 = Math.floor(Math.random()*size);
      const r2 = Math.floor(Math.random()*size), c2 = Math.floor(Math.random()*size);
      const t = board[r1][c1]; board[r1][c1]=board[r2][c2]; board[r2][c2]=t;
    }
    render();
  }

  function shuffleBoard(){
    const flat = board.flat();
    for (let i=flat.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [flat[i], flat[j]] = [flat[j], flat[i]];
    }
    for (let i=0;i<flat.length;i++) board[Math.floor(i/size)][i%size] = flat[i];
    render();
  }

  // Controls
  hintBtn.addEventListener('click', () => {
    const h = findHint();
    if (!h){
      hintBtn.textContent = 'Немає ходів';
      setTimeout(()=> hintBtn.textContent = 'Підказка', 900);
      return;
    }
    h.flat().forEach((_,i) => {
      const [r,c] = i<2 ? h[0] : h[1];
      const el = getCellEl(r,c);
      el.classList.add('good'); setTimeout(()=>el.classList.remove('good'), 500);
    });
  });
  shuffleBtn.addEventListener('click', shuffleBoard);
  newGameBtn.addEventListener('click', newBoard);

  // Start
  newBoard();
})();
</script>
</body>
</html>
